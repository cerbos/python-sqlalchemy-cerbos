import datetime

import uvicorn
from cerbos.engine.v1.engine_pb2 import PlanResourcesInput, Principal, Resource
from cerbos.sdk.grpc.client import CerbosClient
from cerbos_sqlalchemy import get_query
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from google.protobuf import struct_pb2
from sqlalchemy import delete, select

from app.models import Contact, Session, User
from app.schemas import ContactSchema

app = FastAPI()
security = HTTPBasic()


def get_value(v):
    if isinstance(v, str):
        return struct_pb2.Value(string_value=v)
    elif isinstance(v, bool):
        return struct_pb2.Value(bool_value=v)
    elif isinstance(v, (int, float)):
        return struct_pb2.Value(number_value=v)
    elif isinstance(v, datetime.datetime):
        return struct_pb2.Value(number_value=v.timestamp())
    return struct_pb2.Value(null_value=v)


# Stored users:
#   "alice": "admin"
#   "john": "user"
#   "sarah": "user"
#   "geri": "user"
def get_principal(
    credentials: HTTPBasicCredentials = Depends(security),
) -> Principal:
    username = credentials.username

    with Session() as s:
        # retrieve `user` from the DB to access the attributes
        user = s.scalars(select(User).where(User.username == username)).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found",
            )

    return Principal(
        id=str(user.id),
        roles={str(user.role)},
        attr={"department": get_value(user.department)},
    )


def get_db_contact(contact_id: str) -> Contact:
    with Session() as s:
        contact = s.scalars(select(Contact).where(Contact.id == contact_id)).first()
        if contact is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Contact not found",
            )
    return contact


def get_resource_from_contact(
    db_contact: Contact = Depends(get_db_contact),
) -> Resource:
    return Resource(
        id=str(db_contact.id),
        kind="contact",
        attr={
            n.name: get_value(getattr(db_contact, n.name)) for n in Contact.__table__.c
        },
    )


@app.get("/contacts")
async def get_contacts(p: Principal = Depends(get_principal)) -> list[ContactSchema]:
    with CerbosClient("localhost:3593") as c:
        pr = PlanResourcesInput.Resource(kind="contact")

        # Get the query plan for "read" action
        plan = c.plan_resources("read", p, pr)
        # print(json.dumps(plan.to_dict(), sort_keys=False, indent=4))

    query = get_query(
        plan,
        Contact,
        {
            "request.resource.attr.owner_id": User.id,
            "request.resource.attr.department": User.department,
            "request.resource.attr.is_active": Contact.is_active,
            "request.resource.attr.marketing_opt_in": Contact.marketing_opt_in,
        },
        [(User, Contact.owner_id == User.id)],
        # [(User.__table__, Contact.__table__.c.owner_id==User.__table__.c.id)],
    )

    # Optionally reduce the returned columns (`with_only_columns` returns a new `select`)
    # NOTE: this is wise to do as standard, to avoid implicit joins generated by sqla `relationship()` usage, if present
    query = query.with_only_columns(
        Contact.id,
        Contact.first_name,
        Contact.last_name,
        Contact.is_active,
        Contact.marketing_opt_in,
    )
    # print(query.compile(compile_kwargs={"literal_binds": True}))

    with Session() as s:
        rows = s.execute(query).fetchall()

    return rows  # type: ignore


@app.get("/contacts/{contact_id}")
async def get_contact(
    db_contact: Contact = Depends(get_db_contact), p: Principal = Depends(get_principal)
) -> ContactSchema:
    r = get_resource_from_contact(db_contact)

    with CerbosClient("localhost:3593") as c:
        resp = c.is_allowed("read", p, r)
        if not resp:
            # if not c.is_allowed("read", p, r):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Unauthorized"
            )

    return db_contact


@app.post("/contacts/new")
async def create_contact(
    contact_schema: ContactSchema, p: Principal = Depends(get_principal)
) -> dict[str, str | ContactSchema]:
    with CerbosClient("localhost:3593") as c:
        if not c.is_allowed(
            "create",
            p,
            Resource(
                id="new",
                kind="contact",
            ),
        ):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Unauthorized"
            )

    db_contact = Contact(**contact_schema.model_dump())
    with Session() as s:
        s.add(db_contact)
        s.commit()
        s.refresh(db_contact)

    return {"id": db_contact.id, "contact": db_contact}


@app.put("/contacts/{contact_id}")
async def update_contact(
    contact_schema: ContactSchema,
    db_contact: Contact = Depends(get_db_contact),
    p: Principal = Depends(get_principal),
) -> ContactSchema:
    r = get_resource_from_contact(db_contact)

    with CerbosClient("localhost:3593") as c:
        if not c.is_allowed("update", p, r):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Unauthorized"
            )

    for field, value in contact_schema:
        setattr(db_contact, field, value)

    with Session() as s:
        s.add(db_contact)
        s.commit()
        s.refresh(db_contact)

    return db_contact


@app.delete("/contacts/{contact_id}")
async def delete_contact(
    r: Resource = Depends(get_resource_from_contact),
    p: Principal = Depends(get_principal),
) -> dict[str, str]:
    with CerbosClient("localhost:3593") as c:
        if not c.is_allowed("delete", p, r):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Unauthorized"
            )

    with Session() as s:
        s.execute(delete(Contact).where(Contact.id == r.id))
        s.commit()

    return {"result": f"Contact {r.id} deleted"}


if __name__ == "__main__":
    uvicorn.run("main:app", reload=True)
